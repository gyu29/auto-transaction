package com.hanatransaction.security

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import com.hanatransaction.ui.auth.LoginActivity
import java.security.MessageDigest

/**
 * Manages user authentication, login/logout, and password changes
 */
class AuthManager(private val context: Context) {
    
    companion object {
        private const val ENCRYPTED_PREFS_FILENAME = "secured_auth_prefs"
        private const val KEY_USER_ID = "user_id"
        private const val KEY_USERNAME = "username"
        private const val KEY_PASSWORD_HASH = "password_hash"
        private const val KEY_AUTH_TOKEN = "auth_token"
        private const val KEY_SESSION_EXPIRY = "session_expiry"
        
        // Session timeout in milliseconds (24 hours)
        private const val SESSION_TIMEOUT = 24 * 60 * 60 * 1000L
        
        // Minimum password length
        private const val MIN_PASSWORD_LENGTH = 8
    }
    
    private val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()
    
    private val encryptedSharedPreferences = EncryptedSharedPreferences.create(
        context,
        ENCRYPTED_PREFS_FILENAME,
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    // Regular preferences for non-sensitive data
    private val sharedPreferences: SharedPreferences = context.getSharedPreferences(
        "hana_auth_prefs",
        Context.MODE_PRIVATE
    )
    
    /**
     * Check if the user is logged in
     */
    fun isLoggedIn(): Boolean {
        val userId = encryptedSharedPreferences.getLong(KEY_USER_ID, -1)
        val authToken = encryptedSharedPreferences.getString(KEY_AUTH_TOKEN, null)
        val sessionExpiry = encryptedSharedPreferences.getLong(KEY_SESSION_EXPIRY, 0)
        
        // Check if session has expired
        if (System.currentTimeMillis() > sessionExpiry) {
            return false
        }
        
        return userId != -1L && !authToken.isNullOrEmpty()
    }
    
    /**
     * Log in the user automatically (for biometric or PIN authentication)
     * @return True if login successful, false otherwise
     */
    fun login(): Boolean {
        // Create a mock auth token and set session expiry
        val authToken = "auth_token_${System.currentTimeMillis()}"
        val sessionExpiry = System.currentTimeMillis() + SESSION_TIMEOUT
        
        encryptedSharedPreferences.edit()
            .putString(KEY_AUTH_TOKEN, authToken)
            .putLong(KEY_SESSION_EXPIRY, sessionExpiry)
            .apply()
        
        return true
    }
    
    /**
     * Log in with username and password
     * @param username The username
     * @param password The password
     * @return True if login successful, false otherwise
     */
    fun login(username: String, password: String): Boolean {
        // In a real app, this would make an API call to authenticate the user
        // For demo purposes, we'll just check against stored credentials
        
        val storedUsername = encryptedSharedPreferences.getString(KEY_USERNAME, null)
        val storedPasswordHash = encryptedSharedPreferences.getString(KEY_PASSWORD_HASH, null)
        
        // If no credentials are stored, create a new user
        if (storedUsername == null || storedPasswordHash == null) {
            return createUser(username, password)
        }
        
        // Check if credentials match
        val passwordHash = hashPassword(password)
        if (username == storedUsername && passwordHash == storedPasswordHash) {
            // Create a mock auth token and set session expiry
            val authToken = "auth_token_${System.currentTimeMillis()}"
            val sessionExpiry = System.currentTimeMillis() + SESSION_TIMEOUT
            
            encryptedSharedPreferences.edit()
                .putString(KEY_AUTH_TOKEN, authToken)
                .putLong(KEY_SESSION_EXPIRY, sessionExpiry)
                .apply()
            
            return true
        }
        
        return false
    }
    
    /**
     * Create a new user
     * @param username The username
     * @param password The password
     * @return True if user creation successful, false otherwise
     */
    private fun createUser(username: String, password: String): Boolean {
        if (!isValidPassword(password)) return false
        
        val userId = 1L // In a real app, this would be generated by the server
        val passwordHash = hashPassword(password)
        val authToken = "auth_token_${System.currentTimeMillis()}"
        val sessionExpiry = System.currentTimeMillis() + SESSION_TIMEOUT
        
        encryptedSharedPreferences.edit()
            .putLong(KEY_USER_ID, userId)
            .putString(KEY_USERNAME, username)
            .putString(KEY_PASSWORD_HASH, passwordHash)
            .putString(KEY_AUTH_TOKEN, authToken)
            .putLong(KEY_SESSION_EXPIRY, sessionExpiry)
            .apply()
        
        return true
    }
    
    /**
     * Log out the current user
     */
    fun logout() {
        encryptedSharedPreferences.edit()
            .remove(KEY_AUTH_TOKEN)
            .remove(KEY_SESSION_EXPIRY)
            .apply()
        
        // Restart the app to go to the login screen
        val intent = Intent(context, LoginActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        context.startActivity(intent)
    }
    
    /**
     * Change the user's password
     * @param currentPassword The current password
     * @param newPassword The new password
     * @return True if password change successful, false otherwise
     */
    fun changePassword(currentPassword: String, newPassword: String): Boolean {
        if (!isLoggedIn()) return false
        if (!isValidPassword(newPassword)) return false
        
        val storedPasswordHash = encryptedSharedPreferences.getString(KEY_PASSWORD_HASH, null) ?: return false
        val currentPasswordHash = hashPassword(currentPassword)
        
        if (currentPasswordHash != storedPasswordHash) return false
        
        val newPasswordHash = hashPassword(newPassword)
        encryptedSharedPreferences.edit()
            .putString(KEY_PASSWORD_HASH, newPasswordHash)
            .apply()
        
        return true
    }
    
    /**
     * Get the current username
     */
    fun getUsername(): String? {
        return encryptedSharedPreferences.getString(KEY_USERNAME, null)
    }
    
    /**
     * Check if a password is valid (sufficient length and complexity)
     */
    private fun isValidPassword(password: String): Boolean {
        if (password.length < MIN_PASSWORD_LENGTH) return false
        
        // Check for at least one uppercase letter
        if (!password.any { it.isUpperCase() }) return false
        
        // Check for at least one digit
        if (!password.any { it.isDigit() }) return false
        
        return true
    }
    
    /**
     * Hash a password using SHA-256
     */
    private fun hashPassword(password: String): String {
        val bytes = MessageDigest.getInstance("SHA-256").digest(password.toByteArray())
        return bytes.joinToString("") { "%02x".format(it) }
    }
} 